<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ReadFlowBlocks</title>
  <script src="https://unpkg.com/mammoth@1.8.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/RTFJS.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs" type="module"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: sans-serif;
      background: linear-gradient(to bottom right, #256be6, #2ed3b7);
      color: white;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: auto;
    }

    header {
      text-align: center;
      padding: 1rem;
      font-size: clamp(1rem, 2.5vw, 1.5rem);
      font-weight: bold;
      background: rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: clamp(0.5rem, 2vw, 1rem);
      gap: clamp(0.5rem, 1.5vw, 1rem);
      overflow: hidden;
    }

    input[type="file"] {
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: inline-block;
      width: auto;
    }

    input[type="file"]::-webkit-file-upload-button {
      background: #2ed3b7;
      color: black;
      border: none;
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    input[type="file"]::-webkit-file-upload-button:hover {
      transform: scale(1.05);
    }

    input[type="file"]:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    input[type="file"]::-moz-focus-inner {
      border: 0;
    }

    input[type="file"]::after {
      content: attr(data-file-text);
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-left: 0.5rem;
      vertical-align: middle;
    }

    #fullText {
      height: 500px;
      overflow-y: auto;
      padding: clamp(0.5rem, 2vw, 1rem);
      background: rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: clamp(0.8rem, 2.5vw, 1rem);
      line-height: 1.6;
      cursor: pointer;
      position: relative;
    }

    #wordBox {
      text-align: center;
      font-size: clamp(1.2rem, 5vw, 2rem);
      font-weight: bold;
      padding: clamp(0.5rem, 3vw, 1.5rem);
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      min-height: 70px;
    }

    .highlight {
      background: #2ed3b7;
      border-radius: 6px;
      padding: 2px 6px;
      color: black;
      transition: transform 0.2s ease;
    }

    .highlight.clicked {
      transform: scale(1.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: clamp(0.3rem, 1vw, 0.6rem);
    }

    label {
      font-size: clamp(0.6rem, 1.5vw, 0.8rem);
      margin-bottom: 2px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: #2ed3b7;
      height: 4px;
      touch-action: pan-y;
    }

    #pageIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
    }

    #loadingIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      color: #2ed3b7;
      opacity: 0.8;
    }

    .bottom {
      padding-bottom: clamp(0.5rem, 2vw, 1rem);
    }

    #pauseButton,
    #restartButton,
    #rewindBack,
    #rewindForward {
      padding: clamp(0.5rem, 1.5vw, 0.8rem) clamp(0.8rem, 2vw, 1rem);
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      color: black;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin: 0.2rem;
      min-width: 80px;
    }

    #pauseButton:hover,
    #restartButton:hover,
    #rewindBack:hover,
    #rewindForward:hover {
      transform: scale(1.05);
    }

    #progress {
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
      position: relative;
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    #progressBar {
      height: 100%;
      background: #2ed3b7;
      transition: width 0.3s ease;
    }

    #progressText {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      line-height: 20px;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
    }

    #navigation {
      display: flex;
      align-items: center;
      gap: clamp(0.5rem, 1.5vw, 1rem);
      flex-wrap: wrap;
    }

    #chapterSelect {
      padding: clamp(0.3rem, 1vw, 0.5rem);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      border-radius: 5px;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }

    @keyframes pulse {
      from {
        opacity: 0.7;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        gap: 0.5rem;
      }

      header > div {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
      }

      #fullText {
        font-size: 0.9rem;
        line-height: 1.4;
        height: 300px;
      }

      #wordBox {
        font-size: 1.5rem;
        padding: 0.5rem;
      }

      .controls {
        gap: 0.3rem;
      }

      label {
        font-size: 0.7rem;
      }

      input[type="range"] {
        height: 6px;
      }

      #pauseButton,
      #restartButton,
      #rewindBack,
      #rewindForward {
        padding: 0.5rem 0.8rem;
        font-size: 0.9rem;
        min-width: 70px;
      }

      #navigation {
        flex-direction: column;
        gap: 0.5rem;
      }

      #navigationSlider {
        width: 100%;
      }

      #chapterSelect {
        width: 100%;
        font-size: 0.9rem;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      header {
        padding: 0.8rem;
        font-size: 1.2rem;
      }

      #fullText {
        font-size: 0.95rem;
        padding: 0.8rem;
        height: 400px;
      }

      #wordBox {
        font-size: 1.8rem;
        padding: 1rem;
      }

      #pauseButton,
      #restartButton,
      #rewindBack,
      #rewindForward {
        padding: 0.6rem 1rem;
        font-size: 0.95rem;
      }

      #navigation {
        gap: 0.8rem;
      }

      #chapterSelect {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <span>ReadFlowBlocks</span>
    <div>
      <button id="rewindBack">Back 10%</button>
      <button id="pauseButton">Pause</button>
      <button id="restartButton">Restart</button>
      <button id="rewindForward">Forward 10%</button>
    </div>
  </header>

  <main>
    <input type="file" id="fileInput" accept=".txt,.pdf,.docx,.html,.epub,.rtf" data-file-text="No file chosen">
    <div id="loadingIndicator" style="display: none;">Loading...</div>
    <div id="navigation">
      <input type="range" id="navigationSlider" min="0" max="100" value="0">
      <select id="chapterSelect" style="display: none;"></select>
    </div>
    <div id Neисправленный код:
```html
    <div id="fullText"></div>
    <div id="wordBox"></div>
    <div id="pageIndicator">Page 1</div>
    <div id="progress">
      <div id="progressBar" style="width: 0%;"></div>
      <span id="progressText">Progress: 0%</span>
    </div>
    <div class="controls bottom">
      <label for="speedSlider">Speed (words/sec):</label>
      <input type="range" id="speedSlider" min="0.3" max="15" step="0.1" value="1.5">
      <label for="accelSlider">Max Acceleration:</label>
      <input type="range" id="accelSlider" min="0" max="15" step="0.1" value="0">
      <label><input type="checkbox" id="autoAccel"> Auto Acceleration</label>
      <label for="sizeSlider">Text Size:</label>
      <input type="range" id="sizeSlider" min="1" max="4" step="0.1" value="2">
      <label for="wordCountSlider">Number of Words:</label>
      <input type="range" id="wordCountSlider" min="3" max="15" step="1" value="3">
    </div>
  </main>

  <script type="module">
    // Check if running via file://
    if (window.location.protocol === "file:") {
      alert(
        "Please run the application through a local server (e.g., using VS Code Live Server or the command 'python -m http.server 8000'), otherwise file loading may not work due to CORS restrictions."
      );
    }

    // Load pdf.js
    let pdfjsLib;
    try {
      pdfjsLib = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs");
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.mjs";
      console.log("pdf.js successfully loaded");
    } catch (error) {
      console.error("Error loading pdf.js:", error);
      alert("Failed to load the pdf.js library. Check your internet connection or try again later.");
      throw error;
    }

    // Check library loading
    if (typeof mammoth === "undefined") {
      console.error("mammoth.js library not loaded");
      alert("Failed to load the mammoth.js library for processing .docx files. Check your internet connection.");
    } else {
      console.log("mammoth.js successfully loaded");
    }

    if (typeof ePub === "undefined") {
      console.error("epub.js library not loaded");
      alert("Failed to load the epub.js library for processing .epub files. Check your internet connection.");
    } else {
      console.log("epub.js successfully loaded");
    }

    if (typeof RTFJS === "undefined") {
      console.error("rtf.js library not loaded");
      alert("Failed to load the rtf.js library for processing .rtf files. Check your internet connection.");
    } else {
      console.log("rtf.js successfully loaded");
    }

    // Initialize variables
    let words = [],
      current = 0,
      interval,
      isPaused = false;
    let wordBuffer = [];
    const wordBox = document.getElementById("wordBox");
    const fullTextDiv = document.getElementById("fullText");
    const pageIndicator = document.getElementById("pageIndicator");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const pauseButton = document.getElementById("pauseButton");
    const restartButton = document.getElementById("restartButton");
    const rewindBack = document.getElementById("rewindBack");
    const rewindForward = document.getElementById("rewindForward");
    const navigationSlider = document.getElementById("navigationSlider");
    const chapterSelect = document.getElementById("chapterSelect");
    let wordCount = 3;
    let pdfDocument = null;
    let currentPageBatch = 0;
    let totalPages = 0;
    const pagesPerBatch = 5;
    const renderWindow = 100;
    const bufferThreshold = 500;
    let chapters = [];

    // Welcome message
    const welcomeMessage = "This project was created for you, with the hope that it will spark and simplify your interest in reading books. Dive into the world of stories and knowledge with ease, and let this tool make your reading journey both exciting and effortless!";
    const welcomeWords = welcomeMessage.trim().replace(/\s+/g, " ").split(" ");

    // Set welcome message as default
    words = [...welcomeWords];

    // Update file input text
    function updateFileInputText() {
      const fileInput = document.getElementById("fileInput");
      const fileName = fileInput.files.length > 0 ? fileInput.files[0].name : "No file chosen";
      fileInput.setAttribute("data-file-text", fileName);
    }

    // Update text display
    function updateDisplay() {
      const blockStart = current * wordCount;
      const blockEnd = blockStart + wordCount;

      // Refill word buffer
      if (words.length < bufferThreshold && wordBuffer.length > 0) {
        const batchSize = Math.min(500, wordBuffer.length);
        words = words.concat(wordBuffer.splice(0, batchSize));
        console.log(`Added ${batchSize} words from buffer. Current words size: ${words.length}`);
      }

      // Load next batch for PDF
      if (pdfDocument && blockStart >= words.length - wordCount * 5) {
        setTimeout(loadNextBatch, 0);
      }

      // Check for end of text
      if (blockStart >= words.length) {
        wordBox.innerHTML = "";
        fullTextDiv.innerHTML = words.join(" ");
        pageIndicator.textContent = "End";
        progressText.textContent = "Progress: 100%";
        progressBar.style.width = "100%";
        navigationSlider.value = 100;
        localStorage.setItem("readProgress", current);
        pauseButton.textContent = "Finished";
        pauseButton.disabled = true;
        return;
      }

      // Render text
      const renderStart = Math.max(0, blockStart - renderWindow);
      const renderEnd = Math.min(words.length, blockEnd + renderWindow);
      const highlighted = words
        .slice(renderStart, renderEnd)
        .map((w, i) => {
          const globalIndex = renderStart + i;
          return globalIndex >= blockStart && globalIndex < blockEnd
            ? `<span class="highlight" data-index="${globalIndex}">${w}</span>`
            : `<span data-index="${globalIndex}">${w}</span>`;
        })
        .join(" ");

      const currentWords = words.slice(blockStart, blockEnd).join(" ");

      fullTextDiv.innerHTML = highlighted;
      wordBox.innerHTML = currentWords || "Nothing more to read!";
      wordBox.classList.add("next");
      setTimeout(() => wordBox.classList.remove("next"), 400);
      pageIndicator.textContent = `Page ${Math.floor(blockStart / 200) + 1}`;
      const progressPercent = Math.round((blockStart / words.length) * 100);
      progressText.textContent = `Progress: ${progressPercent}%`;
      progressBar.style.width = `${progressPercent}%`;
      navigationSlider.value = progressPercent;

      // Scroll to highlighted text
      const highlightedSpan = fullTextDiv.querySelector(".highlight");
      if (highlightedSpan) {
        const containerHeight = fullTextDiv.clientHeight;
        const spanHeight = highlightedSpan.offsetHeight;
        const spanTop = highlightedSpan.offsetTop;
        const scrollPosition = spanTop - containerHeight / 2 + spanHeight / 2;
        fullTextDiv.scrollTo({
          top: scrollPosition,
          behavior: "smooth",
        });
      }
    }

    // Start reading
    function startReading() {
      if (isPaused) return;
      clearInterval(interval);
      const speed = parseFloat(document.getElementById("speedSlider").value);
      const accelEnabled = document.getElementById("autoAccel").checked;
      const accelLimit = parseFloat(document.getElementById("accelSlider").value);
      let currentSpeed = speed;
      let delay = 1000 / currentSpeed;
      interval = setInterval(() => {
        const blockStart = current * wordCount;
        if (blockStart < words.length) {
          current++;
          updateDisplay();
          if (accelEnabled && currentSpeed < accelLimit) {
            currentSpeed += 0.02;
            delay = 1000 / currentSpeed;
            clearInterval(interval);
            startReading();
          }
        } else {
          current = Math.floor(words.length / wordCount);
          updateDisplay();
          clearInterval(interval);
        }
      }, delay);
    }

    // Pause/resume
    function togglePause() {
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? "Continue" : "Pause";
      if (!isPaused) startReading();
      else clearInterval(interval);
    }

    // Restart reading
    function restartReading() {
      current = 0;
      isPaused = false;
      pauseButton.textContent = "Pause";
      pauseButton.disabled = false;
      updateDisplay();
      startReading();
    }

    // Start reading from a specific word
    function startReadingFromWord(index) {
      if (index >= 0 && index < words.length) {
        current = Math.floor(index / wordCount);
        clearInterval(interval);
        updateDisplay();
        const clickedWord = fullTextDiv.querySelector(`span[data-index="${index}"]`);
        if (clickedWord) {
          clickedWord.classList.add("clicked");
          setTimeout(() => clickedWord.classList.remove("clicked"), 200);
        }
        if (!isPaused) startReading();
      }
    }

    // Navigate to a percentage of progress
    function navigateToPercent(percent) {
      const totalBlocks = Math.floor(words.length / wordCount);
      current = Math.floor(totalBlocks * (percent / 100));
      current = Math.min(current, totalBlocks);
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    // Rewind backward/forward
    function rewind(direction) {
      const totalBlocks = Math.floor(words.length / wordCount);
      const step = Math.floor(totalBlocks * 0.1);
      if (direction === "back") {
        current = Math.max(0, current - step);
      } else {
        current = Math.min(totalBlocks, current + step);
      }
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    // Load next batch of PDF pages
    async function loadNextBatch() {
      if (!pdfDocument || currentPageBatch * pagesPerBatch >= totalPages) return;

      loadingIndicator.style.display = "block";
      const startTime = performance.now();
      let batchText = "";
      const startPage = currentPageBatch * pagesPerBatch + 1;
      const endPage = Math.min(startPage + pagesPerBatch - 1, totalPages);

      try {
        console.log(`Loading pages ${startPage}-${endPage} of ${totalPages}`);
        for (let i = startPage; i <= endPage; i++) {
          console.log(`Processing page ${i}`);
          const page = await pdfDocument.getPage(i);
          const content = await page.getTextContent();
          const pageText = content.items.map((item) => item.str).join(" ");
          console.log(`Page ${i} text: ${pageText.slice(0, 50)}...`);
          batchText += pageText + " ";
        }

        const newWords = batchText.trim().replace(/\s+/g, " ").split(" ");
        console.log(`Extracted ${newWords.length} words`);
        if (newWords.length > 0) {
          wordBuffer = wordBuffer.concat(newWords);
          updateDisplay();
        }

        currentPageBatch++;
        const endTime = performance.now();
        if (currentPageBatch * pagesPerBatch < totalPages) {
          loadingIndicator.textContent = `Loading... (pages ${startPage}-${endPage} of ${totalPages}, time: ${(endTime - startTime).toFixed(2)} ms)`;
        } else {
          loadingIndicator.style.display = "none";
        }
      } catch (error) {
        console.error("Error loading next batch of pages:", error);
        loadingIndicator.textContent = `Error loading pages: ${error.message}`;
      }
    }

    // Handle uploaded file
    async function handleFile(file) {
      if (!file) {
        alert("Please select a file!");
        return;
      }

      const maxSizeMB = 50;
      if (file.size > maxSizeMB * 1024 * 1024) {
        alert(
          `File is too large (${(file.size / (1024 * 1024)).toFixed(2)} MB). Maximum size: ${maxSizeMB} MB.`
        );
        return;
      }

      const ext = file.name.split(".").pop().toLowerCase();
      let text = "";
      pauseButton.disabled = false;
      pauseButton.textContent = "Pause";
      restartButton.disabled = false;
      pdfDocument = null;
      currentPageBatch = 0;
      totalPages = 0;
      words = [];
      wordBuffer = [];
      chapters = [];
      chapterSelect.style.display = "none";
      chapterSelect.innerHTML = "";
      loadingIndicator.style.display = "none";
      navigationSlider.value = 0;

      try {
        if (ext === "txt") {
          console.log("Processing .txt...");
          text = await file.text();
          if (!text) throw new Error("The .txt file is empty or unreadable.");
          console.log(`Extracted text (.txt): ${text.slice(0, 50)}...`);
        } else if (ext === "html") {
          console.log("Processing .html...");
          const html = await file.text();
          const div = document.createElement("div");
          div.innerHTML = html;
          text = div.innerText;
          if (!text.trim()) throw new Error("The .html file contains no text.");
          console.log(`Extracted text (.html): ${text.slice(0, 50)}...`);
        } else if (ext === "pdf") {
          console.log("Processing .pdf...");
          if (!pdfjsLib) throw new Error("The pdf.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          console.log("Loading PDF document...");
          pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          totalPages = pdfDocument.numPages;
          console.log(`Total pages: ${totalPages}`);
          if (totalPages === 0) throw new Error("The PDF file is empty.");

          let pdfText = "";
          const endPage = Math.min(pagesPerBatch, totalPages);
          loadingIndicator.style.display = "block";
          const startTime = performance.now();
          loadingIndicator.textContent = `Loading... (pages 1-${endPage} of ${totalPages})`;

          for (let i = 1; i <= endPage; i++) {
            console.log(`Processing page ${i}`);
            const page = await pdfDocument.getPage(i);
            const content = await page.getTextContent();
            const pageText = content.items.map((item) => item.str).join(" ");
            console.log(`Page ${i} text: ${pageText.slice(0, 50)}...`);
            pdfText += pageText + " ";
          }
          const endTime = performance.now();
          loadingIndicator.textContent = `Loading... (pages 1-${endPage} of ${totalPages}, time: ${(endTime - startTime).toFixed(2)} ms)`;
          text = pdfText;
          currentPageBatch = 1;
          if (currentPageBatch * pagesPerBatch >= totalPages) {
            loadingIndicator.style.display = "none";
          }
        } else if (ext === "docx") {
          console.log("Processing .docx...");
          if (typeof mammoth === "undefined") throw new Error("The mammoth.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const result = await mammoth.extractRawText({ arrayBuffer });
          text = result.value;
          if (!text.trim()) throw new Error("The .docx file is empty or text could not be extracted.");
          console.log(`Extracted text (.docx): ${text.slice(0, 50)}...`);
        } else if (ext === "epub") {
          console.log("Processing .epub...");
          if (typeof ePub === "undefined") throw new Error("The epub.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const book = ePub(arrayBuffer);
          const contents = await book.opened;

          const toc = await book.loaded.navigation;
          let wordIndex = 0;
          chapters = [];
          for (let item of toc.toc) {
            chapters.push({ label: item.label, href: item.href, startIndex: wordIndex });
            const doc = await book.load(item.href);
            const chapterText = (doc.body.innerText || "") + " ";
            const chapterWords = chapterText.trim().replace(/\s+/g, " ").split(" ");
            wordIndex += chapterWords.length;
          }
          if (chapters.length > 0) {
            chapterSelect.style.display = "block";
            chapters.forEach((chapter, idx) => {
              const option = document.createElement("option");
              option.value = idx;
              option.textContent = chapter.label || `Chapter ${idx + 1}`;
              chapterSelect.appendChild(option);
            });
          }

          let epubText = "";
          for (let spineItem of contents.spine.items) {
            const doc = await book.load(spineItem.href);
            epubText += (doc.body.innerText || "") + " ";
          }
          text = epubText;
          if (!text.trim()) throw new Error("The .epub file is empty or text could not be extracted.");
          console.log(`Extracted text (.epub): ${text.slice(0, 50)}...`);
        } else if (ext === "rtf") {
          console.log("Processing .rtf...");
          if (typeof RTFJS === "undefined") throw new Error("The rtf.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const rtfContent = new TextDecoder().decode(arrayBuffer);
          const rtf = new RTFJS.Document(rtfContent);
          text = rtf.getText();
          if (!text.trim()) throw new Error("The .rtf file is empty or text could not be extracted.");
          console.log(`Extracted text (.rtf): ${text.slice(0, 50)}...`);
        } else {
          alert(
            "This format is not supported! Supported formats: .txt, .pdf, .docx, .html, .epub, .rtf."
          );
          return;
        }

        words = text.trim().replace(/\s+/g, " ").split(" ");
        console.log(`Total words after processing: ${words.length}`);
        if (words.length === 0) {
          alert("No words found after processing the file. Try another file.");
          words = [...welcomeWords]; // Revert to welcome message
          return;
        }

        navigationSlider.max = 100;
        navigationSlider.value = 0;

        current = parseInt(localStorage.getItem("readProgress")) || 0;
        isPaused = false;
        updateDisplay();
        startReading();
      } catch (error) {
        console.error(`Error processing file (${ext}):`, error);
        alert(
          `Failed to load file (${ext}): ${error.message}. Check the browser console (F12) for details.`
        );
        loadingIndicator.style.display = "none";
        words = [...welcomeWords]; // Revert to welcome message
        updateDisplay();
        startReading();
      }
    }

    // Event listeners
    document.getElementById("fileInput").addEventListener("change", (e) => {
      updateFileInputText();
      const file = e.target.files[0];
      handleFile(file);
    });

    document.getElementById("speedSlider").addEventListener("input", () => {
      if (!isPaused) startReading();
    });

    document.getElementById("sizeSlider").addEventListener("input", (e) => {
      wordBox.style.fontSize = `${e.target.value}rem`;
    });

    document.getElementById("wordCountSlider").addEventListener("input", (e) => {
      wordCount = Math.max(1, parseInt(e.target.value));
      const currentIndex = current * wordCount;
      current = Math.floor(currentIndex / wordCount);
      updateDisplay();
      if (!isPaused) startReading();
    });

    pauseButton.addEventListener("click", togglePause);
    restartButton.addEventListener("click", restartReading);
    rewindBack.addEventListener("click", () => rewind("back"));
    rewindForward.addEventListener("click", () => rewind("forward"));

    navigationSlider.addEventListener("input", (e) => {
      const percent = parseInt(e.target.value);
      navigateToPercent(percent);
    });

    chapterSelect.addEventListener("change", (e) => {
      const chapterIdx = parseInt(e.target.value);
      const chapter = chapters[chapterIdx];
      if (chapter) {
        const totalBlocks = Math.floor(words.length / wordCount);
        const blockIndex = Math.floor(chapter.startIndex / wordCount);
        current = blockIndex;
        clearInterval(interval);
        updateDisplay();
        if (!isPaused) startReading();
      }
    });

    fullTextDiv.addEventListener("click", (e) => {
      if (e.target.tagName === "SPAN") {
        const index = parseInt(e.target.getAttribute("data-index"));
        if (!isNaN(index)) {
          startReadingFromWord(index);
        }
      }
    });

    // Initialize file input text and start reading welcome message
    updateFileInputText();
    updateDisplay();
    startReading();
  </script>
</body>
</html>
