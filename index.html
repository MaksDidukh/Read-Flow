<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ReadFlowBlocks: A web app for reading text files with customizable speed and navigation.">
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/MaksDidukh/ReadFlowBlocks/refs/heads/main/ReadFlowBlockImageFinal-removebg108_108.png">
  <title>ReadFlowBlocks</title>
  <script src="https://unpkg.com/mammoth@1.8.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/RTFJS.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs" type="module"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: sans-serif;
      background: linear-gradient(to bottom right, #256be6, #2ed3b7);
      color: white;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: auto;
    }
    header {
      text-align: center;
      padding: 1rem;
      font-size: clamp(1rem, 2.5vw, 1.5rem);
      font-weight: bold;
      background: rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: clamp(0.5rem, 2vw, 1rem);
      gap: clamp(0.5rem, 1.5vw, 1rem);
      overflow: hidden;
    }
    footer {
      padding: 1rem;
      background: rgba(0, 0, 0, 0.1);
      text-align: center;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    input[type="file"] {
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    input[type="file"]::-webkit-file-upload-button {
      background: #2ed3b7;
      color: black;
      border: none;
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      transform: scale(1.05);
    }
    input[type="file"]:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    input[type="file"]::after {
      content: attr(data-file-text);
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-left: 0.5rem;
      vertical-align: middle;
    }
    #fullText {
      height: 500px;
      overflow-y: auto;
      padding: clamp(0.5rem, 2vw, 1rem);
      background: rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: clamp(0.8rem, 2.5vw, 1rem);
      line-height: 1.6;
      cursor: pointer;
    }
    #wordBox {
      text-align: center;
      font-size: clamp(1.2rem, 5vw, 2rem);
      font-weight: bold;
      padding: clamp(0.5rem, 3vw, 1.5rem);
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      min-height: 70px;
    }
    .highlight {
      background: #2ed3b7;
      border-radius: 6px;
      padding: 2px 6px;
      color: black;
      transition: transform 0.2s ease;
    }
    .highlight.clicked {
      transform: scale(1.1);
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: clamp(0.3rem, 1vw, 0.6rem);
    }
    label {
      font-size: clamp(0.6rem, 1.5vw, 0.8rem);
      margin-bottom: 2px;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #2ed3b7;
      height: 4px;
    }
    #pageIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
    }
    #loadingIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      color: #2ed3b7;
      opacity: 0.8;
    }
    .bottom {
      padding-bottom: clamp(0.5rem, 2vw, 1rem);
    }
    #pauseButton,
    #restartButton,
    #rewindBack,
    #rewindForward {
      padding: clamp(0.5rem, 1.5vw, 0.8rem) clamp(0.8rem, 2vw, 1rem);
      background: #2ed3b7 !important;
      border: none;
      border-radius: 5px;
      color: black !important;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.3s ease;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin: 0.2rem;
      min-width: 80px;
    }
    #pauseButton:hover,
    #restartButton:hover,
    #rewindBack:hover,
    #rewindForward:hover {
      transform: scale(1.05);
      background: #26b8a0 !important;
    }
    #progress {
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
      position: relative;
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }
    #progressBar {
      height: 100%;
      background: #2ed3b7;
      transition: width 0.3s ease;
    }
    #progressText {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      line-height: 20px;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
    }
    #navigation {
      display: flex;
      align-items: center;
      gap: clamp(0.5rem, 1.5vw, 1rem);
      flex-wrap: wrap;
    }
    #chapterSelect {
      padding: clamp(0.3rem, 1vw, 0.5rem);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      border-radius: 5px;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal.show {
      display: flex;
    }
    .modal-content {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: clamp(1rem, 2vw, 2rem);
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      color: white;
      font-size: clamp(0.9rem, 2vw, 1.1rem);
      line-height: 1.6;
    }
    .modal-content h2 {
      font-size: clamp(1.2rem, 3vw, 1.5rem);
      margin-bottom: 1rem;
    }
    .modal-content a {
      color: #2ed3b7;
      text-decoration: none;
    }
    .modal-content a:hover {
      text-decoration: underline;
    }
    .modal-content ul {
      margin: 1rem 0;
      padding-left: 1.5rem;
    }
    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      padding: 0.5rem 1rem;
      color: black;
      font-weight: bold;
      cursor: pointer;
    }
    .modal-close:hover {
      transform: scale(1.05);
    }
    .modal-button {
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      padding: 0.5rem 1rem;
      color: black;
      font-weight: bold;
      cursor: pointer;
      margin: 0.5rem;
    }
    .modal-button.decline {
      background: #ff4d4d;
    }
    .modal-button:hover {
      transform: scale(1.05);
    }
    .footer-link {
      background: none;
      border: none;
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      cursor: pointer;
      margin: 0 0.5rem;
    }
    .footer-link:hover {
      color: #2ed3b7;
    }
    .locked main,
    .locked header,
    .locked footer {
      pointer-events: none;
      opacity: 0.5;
    }
    #corsWarning {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      color: #ff4d4d;
      margin-bottom: 0.5rem;
      display: none;
    }
    @media (max-width: 768px) {
      header {
        flex-direction: column;
        gap: 0.5rem;
      }
      header > div {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
      }
      #fullText {
        font-size: 0.9rem;
        height: 300px;
      }
      #wordBox {
        font-size: 1.5rem;
        padding: 0.5rem;
      }
      #pauseButton,
      #restartButton,
      #rewindBack,
      #rewindForward {
        padding: 0.5rem 0.8rem;
        font-size: 0.9rem;
        min-width: 70px;
      }
      #navigation {
        flex-direction: column;
        gap: 0.5rem;
      }
      .modal-content {
        font-size: 0.85rem;
        padding: 1rem;
      }
    }
    @media (min-width: 769px) and (max-width: 1024px) {
      #fullText {
        font-size: 0.95rem;
        height: 400px;
      }
      #wordBox {
        font-size: 1.8rem;
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <span>ReadFlowBlocks <img src="https://raw.githubusercontent.com/MaksDidukh/ReadFlowBlocks/refs/heads/main/ReadFlowBlockImageFinal-removebg108_108.png" alt="ReadFlowBlocks Icon" style="width: 1.5rem; height: 1.5rem; vertical-align: middle;"></span>
    <div>
      <button id="rewindBack" aria-label="Rewind Back 10%">Back 10%</button>
      <button id="pauseButton" aria-label="Pause Reading">Pause</button>
      <button id="restartButton" aria-label="Restart Reading">Restart</button>
      <button id="rewindForward" aria-label="Rewind Forward 10%">Forward 10%</button>
    </div>
  </header>
  <main>
    <div id="corsWarning">Note: For best experience, run this app via a local server (e.g., 'python -m http.server') or host it online.</div>
    <input type="file" id="fileInput" accept=".txt,.pdf,.docx,.html,.epub,.rtf" data-file-text="No file chosen" aria-label="Upload a text file">
    <div id="loadingIndicator" style="display: none;">Loading...</div>
    <div id="navigation">
      <input type="range" id="navigationSlider" min="0" max="100" value="0" aria-label="Navigate reading progress">
      <select id="chapterSelect" style="display: none;" aria-label="Select chapter"></select>
    </div>
    <div id="fullText" role="region" aria-label="Full text display"></div>
    <div id="wordBox" role="region" aria-label="Current word display"></div>
    <div id="pageIndicator" aria-live="polite">Page 1</div>
    <div id="progress" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
      <div id="progressBar" style="width: 0%;"></div>
      <span id="progressText" aria-live="polite">Progress: 0%</span>
    </div>
    <div class="controls bottom">
      <label for="speedSlider">Speed (words/sec):</label>
      <input type="range" id="speedSlider" min="0.3" max="15" step="0.1" value="1.5" aria-label="Adjust reading speed">
      <label for="accelSlider">Max Acceleration:</label>
      <input type="range" id="accelSlider" min="0" max="15" step="0.1" value="0" aria-label="Adjust maximum acceleration">
      <label><input type="checkbox" id="autoAccel" aria-label="Enable auto acceleration"> Auto Acceleration</label>
      <label for="sizeSlider">Text Size:</label>
      <input type="range" id="sizeSlider" min="1" max="4" step="0.1" value="2" aria-label="Adjust text size">
      <label for="wordCountSlider">Number of Words:</label>
      <input type="range" id="wordCountSlider" min="3" max="15" step="1" value="3" aria-label="Adjust number of words displayed">
    </div>
  </main>
  <footer>
    <button class="footer-link" onclick="showModal('aboutModal')" aria-label="View About">About</button>
    <button class="footer-link" onclick="showModal('privacyModal')" aria-label="View Privacy Policy">Privacy Policy</button>
    <span>Hosted on <a href="https://www.netlify.com" target="_blank" style="color: #2ed3b7;">Netlify</a></span>
  </footer>
  <div id="termsModal" class="modal" role="dialog" aria-labelledby="termsModalTitle">
    <div class="modal-content">
      <h2 id="termsModalTitle">Terms of Use</h2>
      <p><strong>Effective Date</strong>: April 18, 2025</p>
      <p>Welcome to ReadFlowBlocks. By using this application, you agree to the following Terms of Use.</p>
      <h3>1. Acceptance of Terms</h3>
      <p>By accessing or using ReadFlowBlocks, you agree to be bound by these Terms of Use and our Privacy Policy.</p>
      <h3>2. Use of the Application</h3>
      <p>- For personal, non-commercial use.</p>
      <p>- You are responsible for ensuring that uploaded files comply with intellectual property rights.</p>
      <h3>3. Local Processing</h3>
      <p>- All files are processed locally in your browser. No data is transmitted to our servers.</p>
      <h3>4. Intellectual Property</h3>
      <p>- ReadFlowBlocks is the intellectual property of Maksym Didukh.</p>
      <h3>5. Limitation of Liability</h3>
      <p>- Provided "as is" without warranties.</p>
      <h3>6. Contact Information</h3>
      <p>Email: <a href="mailto:didukh.maxim@gmail.com">didukh.maxim@gmail.com</a></p>
      <div style="display: flex; justify-content: center; gap: 1rem;">
        <button class="modal-button" id="acceptTermsButton" aria-label="Accept Terms">Accept</button>
        <button class="modal-button decline" id="declineTermsButton" aria-label="Decline Terms">Decline</button>
      </div>
    </div>
  </div>
  <div id="welcomeModal" class="modal" role="dialog" aria-labelledby="welcomeModalTitle">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('welcomeModal')" aria-label="Close Welcome Modal">Close</button>
      <h2 id="welcomeModalTitle">Welcome to ReadFlowBlocks</h2>
      <p>Files are processed locally, ensuring privacy.</p>
      <label><input type="checkbox" id="dontShowAgain" aria-label="Do not show again"> Don't show again</label>
      <button class="modal-button" onclick="closeModal('welcomeModal')" aria-label="Close Welcome Modal">OK</button>
    </div>
  </div>
  <div id="aboutModal" class="modal" role="dialog" aria-labelledby="aboutModalTitle">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('aboutModal')" aria-label="Close About Modal">Close</button>
      <h2 id="aboutModalTitle">About ReadFlowBlocks</h2>
      <p>ReadFlowBlocks enhances your reading experience with customizable speed and navigation.</p>
      <p>Developer: Maksym Didukh</p>
    </div>
  </div>
  <div id="privacyModal" class="modal" role="dialog" aria-labelledby="privacyModalTitle">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('privacyModal')" aria-label="Close Privacy Modal">Close</button>
      <h2 id="privacyModalTitle">Privacy Policy</h2>
      <p><strong>Effective Date</strong>: April 18, 2025</p>
      <p>No data is collected or stored on our servers.</p>
      <button class="modal-button" id="clearCacheButton" aria-label="Clear Cache">Clear Application Cache</button>
    </div>
  </div>
  <script>
    if (window.location.protocol === "file:") {
      document.getElementById("corsWarning").style.display = "block";
    }

    let pdfjsLib;
    import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs")
      .then(module => {
        pdfjsLib = module;
        pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.mjs";
      })
      .catch(error => {
        console.error("Error loading pdf.js:", error);
        alert("Failed to load pdf.js. Check your connection.");
      });

    let words = [],
      current = 0,
      interval,
      isPaused = false;
    let wordBuffer = [];
    const wordBox = document.getElementById("wordBox");
    const fullTextDiv = document.getElementById("fullText");
    const pageIndicator = document.getElementById("pageIndicator");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const pauseButton = document.getElementById("pauseButton");
    const restartButton = document.getElementById("restartButton");
    const rewindBack = document.getElementById("rewindBack");
    const rewindForward = document.getElementById("rewindForward");
    const navigationSlider = document.getElementById("navigationSlider");
    const chapterSelect = document.getElementById("chapterSelect");
    let wordCount = 3;
    let pdfDocument = null;
    let currentPageBatch = 0;
    let totalPages = 0;
    const pagesPerBatch = 20;
    const renderWindow = 100;
    let chapters = [];
    let isLoadingBatch = false;

    const welcomeMessage = "This project was created to simplify your reading experience!";
    words = welcomeMessage.trim().replace(/\s+/g, " ").split(" ");

    function updateFileInputText() {
      const fileInput = document.getElementById("fileInput");
      fileInput.setAttribute("data-file-text", fileInput.files.length > 0 ? fileInput.files[0].name : "No file chosen");
    }

    function updateDisplay() {
      const blockStart = current * wordCount;
      const blockEnd = blockStart + wordCount;

      if (pdfDocument && currentPageBatch * pagesPerBatch < totalPages && !isLoadingBatch) {
        loadNextBatch();
      }

      if (blockStart >= words.length && wordBuffer.length === 0 && currentPageBatch * pagesPerBatch >= totalPages) {
        wordBox.innerHTML = "Finished!";
        fullTextDiv.innerHTML = words.join(" ");
        pageIndicator.textContent = "End";
        progressText.textContent = "Progress: 100%";
        progressBar.style.width = "100%";
        navigationSlider.value = 100;
        pauseButton.textContent = "Continue";
        clearInterval(interval);
        return;
      }

      if (words.length < 1000 && wordBuffer.length > 0) {
        words = words.concat(wordBuffer.splice(0, wordBuffer.length));
        console.log(`Moved ${words.length} words from buffer. Total: ${words.length}`);
      }

      const renderStart = Math.max(0, blockStart - renderWindow);
      const renderEnd = Math.min(words.length, blockEnd + renderWindow);
      const highlighted = words
        .slice(renderStart, renderEnd)
        .map((w, i) => {
          const idx = renderStart + i;
          return idx >= blockStart && idx < blockEnd
            ? `<span class="highlight" data-index="${idx}">${w}</span>`
            : `<span data-index="${idx}">${w}</span>`;
        })
        .join(" ");

      wordBox.innerHTML = words.slice(blockStart, blockEnd).join(" ") || "Loading...";
      fullTextDiv.innerHTML = highlighted;
      pageIndicator.textContent = `Page ${Math.floor(blockStart / 200) + 1}`;
      const progressPercent = Math.min(100, Math.round((blockStart / words.length) * 100));
      progressText.textContent = `Progress: ${progressPercent}%`;
      progressBar.style.width = `${progressPercent}%`;
      navigationSlider.value = progressPercent;

      const highlightedSpan = fullTextDiv.querySelector(".highlight");
      if (highlightedSpan) {
        const containerHeight = fullTextDiv.clientHeight;
        const spanTop = highlightedSpan.offsetTop;
        fullTextDiv.scrollTo({ top: spanTop - containerHeight / 2, behavior: "smooth" });
      }
    }

    function startReading() {
      if (isPaused) return;
      clearInterval(interval);
      const speed = parseFloat(document.getElementById("speedSlider").value);
      const accelEnabled = document.getElementById("autoAccel").checked;
      const accelLimit = parseFloat(document.getElementById("accelSlider").value);
      let currentSpeed = speed;
      let delay = 1000 / currentSpeed;
      interval = setInterval(() => {
        const blockStart = current * wordCount;
        if (blockStart < words.length) {
          current++;
          updateDisplay();
          if (accelEnabled && currentSpeed < accelLimit) {
            currentSpeed += 0.02;
            delay = 1000 / currentSpeed;
            clearInterval(interval);
            startReading();
          }
        } else if (currentPageBatch * pagesPerBatch < totalPages || wordBuffer.length > 0) {
          updateDisplay();
        } else {
          clearInterval(interval);
        }
      }, delay);
    }

    function togglePause() {
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? "Continue" : "Pause";
      pauseButton.style.background = "#2ed3b7";
      if (!isPaused) {
        const blockStart = current * wordCount;
        if (blockStart >= words.length) {
          restartReading();
        } else {
          startReading();
        }
      } else {
        clearInterval(interval);
      }
    }

    function restartReading() {
      current = 0;
      isPaused = false;
      pauseButton.textContent = "Pause";
      pauseButton.style.background = "#2ed3b7";
      updateDisplay();
      startReading();
    }

    function navigateToPercent(percent) {
      const totalBlocks = Math.floor(words.length / wordCount);
      current = Math.floor(totalBlocks * (percent / 100));
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    function rewind(direction) {
      const totalBlocks = Math.floor(words.length / wordCount);
      const step = Math.floor(totalBlocks * 0.1);
      current = direction === "back" ? Math.max(0, current - step) : Math.min(totalBlocks, current + step);
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    async function loadNextBatch() {
      if (!pdfDocument || currentPageBatch * pagesPerBatch >= totalPages || isLoadingBatch) {
        console.log(`loadNextBatch skipped: currentPageBatch=${currentPageBatch}, totalPages=${totalPages}`);
        return;
      }
      isLoadingBatch = true;
      loadingIndicator.style.display = "block";
      const startPage = currentPageBatch * pagesPerBatch + 1;
      const endPage = Math.min(startPage + pagesPerBatch - 1, totalPages);
      let batchText = "";
      try {
        console.log(`Loading pages ${startPage}-${endPage} of ${totalPages}`);
        loadingIndicator.textContent = `Loading pages ${startPage}-${endPage} of ${totalPages} (${Math.round((endPage / totalPages) * 100)}%)...`;
        for (let i = startPage; i <= endPage; i++) {
          try {
            const page = await pdfDocument.getPage(i);
            const content = await page.getTextContent();
            const pageText = content.items.map((item) => item.str).join(" ");
            if (pageText.trim()) {
              batchText += pageText + " ";
              console.log(`Page ${i}: ${pageText.slice(0, 50)}...`);
            } else {
              console.log(`Page ${i} is empty, skipping`);
            }
          } catch (pageError) {
            console.error(`Error on page ${i}:`, pageError);
            continue;
          }
        }
        const newWords = batchText.trim().replace(/\s+/g, " ").split(" ");
        if (newWords.length > 0) {
          wordBuffer = wordBuffer.concat(newWords);
          console.log(`Added ${newWords.length} words from pages ${startPage}-${endPage}. Buffer size: ${wordBuffer.length}`);
          if (words.length < 1000) {
            words = words.concat(wordBuffer.splice(0, wordBuffer.length));
            console.log(`Moved ${newWords.length} words to words. Total: ${words.length}`);
          }
        }
        currentPageBatch++;
        if (currentPageBatch * pagesPerBatch >= totalPages) {
          loadingIndicator.textContent = "All pages loaded!";
          setTimeout(() => (loadingIndicator.style.display = "none"), 2000);
        }
      } catch (error) {
        console.error(`Error loading pages ${startPage}-${endPage}:`, error);
        loadingIndicator.textContent = `Error loading pages ${startPage}-${endPage}. Continuing...`;
      } finally {
        isLoadingBatch = false;
        updateDisplay();
      }
    }

    async function handleFile(file) {
      if (!file) {
        alert("Please select a file!");
        return;
      }
      if (file.size > 100 * 1024 * 1024) {
        alert("File is too large. Maximum size: 100 MB.");
        return;
      }
      alert("Ensure you have the legal right to use this file.");

      const ext = file.name.split(".").pop().toLowerCase();
      let text = "";
      pdfDocument = null;
      currentPageBatch = 0;
      totalPages = 0;
      words = [];
      wordBuffer = [];
      chapters = [];
      chapterSelect.style.display = "none";
      chapterSelect.innerHTML = "";
      loadingIndicator.style.display = "none";

      try {
        if (ext === "txt") {
          text = await file.text();
        } else if (ext === "html") {
          text = (await file.text()).replace(/<[^>]+>/g, "");
        } else if (ext === "pdf") {
          if (!pdfjsLib) throw new Error("pdf.js not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          totalPages = pdfDocument.numPages;
          const endPage = Math.min(pagesPerBatch, totalPages);
          loadingIndicator.style.display = "block";
          loadingIndicator.textContent = `Loading pages 1-${endPage} of ${totalPages}...`;
          let pdfText = "";
          for (let i = 1; i <= endPage; i++) {
            try {
              const page = await pdfDocument.getPage(i);
              const content = await page.getTextContent();
              const pageText = content.items.map((item) => item.str).join(" ");
              pdfText += pageText + " ";
              console.log(`Page ${i}: ${pageText.slice(0, 50)}...`);
            } catch (pageError) {
              console.error(`Error on page ${i}:`, pageError);
            }
          }
          text = pdfText;
          currentPageBatch = 1;
        } else if (ext === "docx") {
          const arrayBuffer = await file.arrayBuffer();
          text = (await mammoth.extractRawText({ arrayBuffer })).value;
        } else if (ext === "epub") {
          const arrayBuffer = await file.arrayBuffer();
          const book = ePub(arrayBuffer);
          const contents = await book.opened;
          let epubText = "";
          for (let spineItem of contents.spine.items) {
            const doc = await book.load(spineItem.href);
            epubText += (doc.body.innerText || "") + " ";
          }
          text = epubText;
        } else if (ext === "rtf") {
          const arrayBuffer = await file.arrayBuffer();
          const rtfContent = new TextDecoder().decode(arrayBuffer);
          text = new RTFJS.Document(rtfContent).getText();
        } else {
          alert("Unsupported format. Supported: .txt, .pdf, .docx, .html, .epub, .rtf.");
          return;
        }

        words = text.trim().replace(/\s+/g, " ").split(" ");
        if (words.length === 0) {
          alert("No words found in the file.");
          words = welcomeMessage.trim().replace(/\s+/g, " ").split(" ");
        }
        current = 0;
        isPaused = false;
        updateDisplay();
        startReading();
      } catch (error) {
        console.error("Error processing file:", error);
        alert("Failed to load file: " + error.message);
        words = welcomeMessage.trim().replace(/\s+/g, " ").split(" ");
        updateDisplay();
        startReading();
      }
    }

    document.getElementById("fileInput").addEventListener("change", (e) => {
      updateFileInputText();
      handleFile(e.target.files[0]);
    });

    document.getElementById("speedSlider").addEventListener("input", startReading);
    document.getElementById("sizeSlider").addEventListener("input", (e) => {
      wordBox.style.fontSize = `${e.target.value}rem`;
    });
    document.getElementById("wordCountSlider").addEventListener("input", (e) => {
      wordCount = parseInt(e.target.value);
      current = Math.floor((current * wordCount) / wordCount);
      updateDisplay();
      if (!isPaused) startReading();
    });

    pauseButton.addEventListener("click", togglePause);
    restartButton.addEventListener("click", restartReading);
    rewindBack.addEventListener("click", () => rewind("back"));
    rewindForward.addEventListener("click", () => rewind("forward"));
    navigationSlider.addEventListener("input", (e) => navigateToPercent(parseInt(e.target.value)));

    fullTextDiv.addEventListener("click", (e) => {
      if (e.target.tagName === "SPAN") {
        const index = parseInt(e.target.getAttribute("data-index"));
        if (!isNaN(index)) {
          current = Math.floor(index / wordCount);
          updateDisplay();
          if (!isPaused) startReading();
        }
      }
    });

    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      modal.classList.add("show");
      modal.style.display = "flex";
    }

    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      modal.classList.remove("show");
      modal.style.display = "none";
      if (modalId === "welcomeModal" && document.getElementById("dontShowAgain").checked) {
        localStorage.setItem("hideWelcomeModal", "true");
      }
    }

    function acceptTerms() {
      localStorage.setItem("termsAccepted", "true");
      document.body.classList.remove("locked");
      closeModal("termsModal");
      if (!localStorage.getItem("hideWelcomeModal")) showModal("welcomeModal");
    }

    function declineTerms() {
      alert("You must accept the Terms of Use to continue.");
    }

    function clearCache() {
      localStorage.clear();
      closeModal("privacyModal");
      window.location.reload();
    }

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("acceptTermsButton").addEventListener("click", acceptTerms);
      document.getElementById("declineTermsButton").addEventListener("click", declineTerms);
      document.getElementById("clearCacheButton").addEventListener("click", clearCache);
      if (!localStorage.getItem("termsAccepted")) {
        document.body.classList.add("locked");
        showModal("termsModal");
      } else if (!localStorage.getItem("hideWelcomeModal")) {
        showModal("welcomeModal");
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        ["termsModal", "welcomeModal", "aboutModal", "privacyModal"].forEach(closeModal);
      }
    });

    updateFileInputText();
    updateDisplay();
    startReading();
  </script>
</body>
</html>
