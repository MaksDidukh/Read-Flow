<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/MaksDidukh/ReadFlowBlocks/refs/heads/main/ReadFlowBlockImageFinal-removebg108_108.png">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ReadFlowBlocks</title>
  <script src="https://unpkg.com/mammoth@1.8.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>
  <script src="https://unpkg.com/rtf.js@3.0.9/dist/RTFJS.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs" type="module"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: sans-serif;
      background: linear-gradient(to bottom right, #256be6, #2ed3b7);
      color: white;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: auto;
    }
    header {
      text-align: center;
      padding: 1rem;
      font-size: clamp(1rem, 2.5vw, 1.5rem);
      font-weight: bold;
      background: rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: clamp(0.5rem, 2vw, 1rem);
      gap: clamp(0.5rem, 1.5vw, 1rem);
      overflow: hidden;
    }
    footer {
      padding: 1rem;
      background: rgba(0, 0, 0, 0.1);
      text-align: center;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    input[type="file"] {
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: inline-block;
      width: auto;
    }
    input[type="file"]::-webkit-file-upload-button {
      background: #2ed3b7;
      color: black;
      border: none;
      border-radius: 5px;
      padding: clamp(0.3rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.8rem);
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      transform: scale(1.05);
    }
    input[type="file"]:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    input[type="file"]::-moz-focus-inner {
      border: 0;
    }
    input[type="file"]::after {
      content: attr(data-file-text);
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin-left: 0.5rem;
      vertical-align: middle;
    }
    #fullText {
      height: 500px;
      overflow-y: auto;
      padding: clamp(0.5rem, 2vw, 1rem);
      background: rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: clamp(0.8rem, 2.5vw, 1rem);
      line-height: 1.6;
      cursor: pointer;
      position: relative;
    }
    #wordBox {
      text-align: center;
      font-size: clamp(1.2rem, 5vw, 2rem);
      font-weight: bold;
      padding: clamp(0.5rem, 3vw, 1.5rem);
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      min-height: 70px;
    }
    .highlight {
      background: #2ed3b7;
      border-radius: 6px;
      padding: 2px 6px;
      color: black;
      transition: transform 0.2s ease;
    }
    .highlight.clicked {
      transform: scale(1.1);
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: clamp(0.3rem, 1vw, 0.6rem);
    }
    label {
      font-size: clamp(0.6rem, 1.5vw, 0.8rem);
      margin-bottom: 2px;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #2ed3b7;
      height: 4px;
      touch-action: pan-y;
    }
    #pageIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
    }
    #loadingIndicator {
      text-align: center;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      color: #2ed3b7;
      opacity: 0.8;
    }
    .bottom {
      padding-bottom: clamp(0.5rem, 2vw, 1rem);
    }
    #pauseButton,
    #restartButton,
    #rewindBack,
    #rewindForward {
      padding: clamp(0.5rem, 1.5vw, 0.8rem) clamp(0.8rem, 2vw, 1rem);
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      color: black;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
      font-size: clamp(0.8rem, 2vw, 1rem);
      margin: 0.2rem;
      min-width: 80px;
    }
    #pauseButton:hover,
    #restartButton:hover,
    #rewindBack:hover,
    #rewindForward:hover {
      transform: scale(1.05);
    }
    #progress {
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
      opacity: 0.8;
      position: relative;
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }
    #progressBar {
      height: 100%;
      background: #2ed3b7;
      transition: width 0.3s ease;
    }
    #progressText {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      line-height: 20px;
      font-size: clamp(0.7rem, 1.5vw, 0.9rem);
    }
    #navigation {
      display: flex;
      align-items: center;
      gap: clamp(0.5rem, 1.5vw, 1rem);
      flex-wrap: wrap;
    }
    #chapterSelect {
      padding: clamp(0.3rem, 1vw, 0.5rem);
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      border-radius: 5px;
      font-size: clamp(0.8rem, 2vw, 1rem);
    }
    /* Стили для модального окна */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: clamp(1rem, 2vw, 2rem);
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      color: white;
      font-size: clamp(0.9rem, 2vw, 1.1rem);
      line-height: 1.6;
      position: relative;
    }
    .modal-content h2 {
      font-size: clamp(1.2rem, 3vw, 1.5rem);
      margin-bottom: 1rem;
    }
    .modal-content a {
      color: #2ed3b7;
      text-decoration: none;
    }
    .modal-content a:hover {
      text-decoration: underline;
    }
    .modal-content ul {
      margin: 1rem 0;
      padding-left: 1.5rem;
    }
    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      padding: 0.5rem 1rem;
      color: black;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .modal-close:hover {
      transform: scale(1.05);
    }
    .modal-button {
      background: #2ed3b7;
      border: none;
      border-radius: 5px;
      padding: 0.5rem 1rem;
      color: black;
      font-weight: bold;
      cursor: pointer;
      margin: 0.5rem;
      transition: transform 0.2s ease;
    }
    .modal-button:hover {
      transform: scale(1.05);
    }
    .footer-link {
      background: none;
      border: none;
      color: white;
      font-size: clamp(0.8rem, 2vw, 1rem);
      cursor: pointer;
      margin: 0 0.5rem;
      transition: color 0.3s ease;
    }
    .footer-link:hover {
      color: #2ed3b7;
    }
    @keyframes pulse {
      from {
        opacity: 0.7;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (max-width: 768px) {
      header {
        flex-direction: column;
        gap: 0.5rem;
      }
      header > div {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
      }
      #fullText {
        font-size: 0.9rem;
        line-height: 1.4;
        height: 300px;
      }
      #wordBox {
        font-size: 1.5rem;
        padding: 0.5rem;
      }
      .controls {
        gap: 0.3rem;
      }
      label {
        font-size: 0.7rem;
      }
      input[type="range"] {
        height: 6px;
      }
      #pauseButton,
      #restartButton,
      #rewindBack,
      #rewindForward {
        padding: 0.5rem 0.8rem;
        font-size: 0.9rem;
        min-width: 70px;
      }
      #navigation {
        flex-direction: column;
        gap: 0.5rem;
      }
      #navigationSlider {
        width: 100%;
      }
      #chapterSelect {
        width: 100%;
        font-size: 0.9rem;
      }
      .modal-content {
        font-size: 0.85rem;
        padding: 1rem;
      }
      .modal-content h2 {
        font-size: 1.2rem;
      }
    }
    @media (min-width: 769px) and (max-width: 1024px) {
      header {
        padding: 0.8rem;
        font-size: 1.2rem;
      }
      #fullText {
        font-size: 0.95rem;
        padding: 0.8rem;
        height: 400px;
      }
      #wordBox {
        font-size: 1.8rem;
        padding: 1rem;
      }
      #pauseButton,
      #restartButton,
      #rewindBack,
      #rewindForward {
        padding: 0.6rem 1rem;
        font-size: 0.95rem;
      }
      #navigation {
        gap: 0.8rem;
      }
      #chapterSelect {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <span>ReadFlowBlocks <img src="https://raw.githubusercontent.com/MaksDidukh/ReadFlowBlocks/refs/heads/main/ReadFlowBlockImageFinal-removebg108_108.png" alt="ReadFlowBlocks Icon" style="width: 1.5rem; height: 1.5rem; vertical-align: middle;"></span>
    <div>
      <button id="rewindBack">Back 10%</button>
      <button id="pauseButton">Pause</button>
      <button id="restartButton">Restart</button>
      <button id="rewindForward">Forward 10%</button>
    </div>
  </header>
  <main>
    <input type="file" id="fileInput" accept=".txt,.pdf,.docx,.html,.epub,.rtf" data-file-text="No file chosen">
    <div id="loadingIndicator" style="display: none;">Loading...</div>
    <div id="navigation">
      <input type="range" id="navigationSlider" min="0" max="100" value="0">
      <select id="chapterSelect" style="display: none;"></select>
    </div>
    <div id="fullText"></div>
    <div id="wordBox"></div>
    <div id="pageIndicator">Page 1</div>
    <div id="progress">
      <div id="progressBar" style="width: 0%;"></div>
      <span id="progressText">Progress: 0%</span>
    </div>
    <div class="controls bottom">
      <label for="speedSlider">Speed (words/sec):</label>
      <input type="range" id="speedSlider" min="0.3" max="15" step="0.1" value="1.5">
      <label for="accelSlider">Max Acceleration:</label>
      <input type="range" id="accelSlider" min="0" max="15" step="0.1" value="0">
      <label><input type="checkbox" id="autoAccel"> Auto Acceleration</label>
      <label for="sizeSlider">Text Size:</label>
      <input type="range" id="sizeSlider" min="1" max="4" step="0.1" value="2">
      <label for="wordCountSlider">Number of Words:</label>
      <input type="range" id="wordCountSlider" min="3" max="15" step="1" value="3">
    </div>
  </main>
  <footer>
    <button class="footer-link" onclick="showModal('about')">About</button>
    <button class="footer-link" onclick="showModal('privacy')">Privacy Policy</button>
  </footer>
  <!-- Модальное окно для приветствия -->
  <div id="welcomeModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('welcomeModal')">Close</button>
      <h2>Welcome to ReadFlowBlocks</h2>
      <p>ReadFlowBlocks processes all your files locally in your browser, ensuring your data stays private. No data is sent to our servers.</p>
      <p>Learn more about our <a href="#" onclick="showModal('privacy'); closeModal('welcomeModal')">Privacy Policy</a>.</p>
      <label><input type="checkbox" id="dontShowAgain"> Don't show again</label>
      <div>
        <button class="modal-button" onclick="closeModal('welcomeModal')">OK</button>
      </div>
    </div>
  </div>
  <!-- Модальное окно для About -->
  <div id="aboutModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('aboutModal')">Close</button>
      <h2>About ReadFlowBlocks</h2>
      <p>ReadFlowBlocks is an innovative web application designed to simplify and enhance your reading experience. Upload books in .txt, .pdf, .docx, .html, .epub, or .rtf formats and enjoy reading with customizable speed, word count, and chapter navigation.</p>
      <h3>Key Features</h3>
      <ul>
        <li>Support for multiple file formats (.txt, .pdf, .docx, .html, .epub, .rtf).</li>
        <li>Adjustable reading speed and auto-acceleration.</li>
        <li>Interactive text and chapter navigation.</li>
        <li>Progress tracking and text size customization.</li>
        <li>Simple and intuitive interface.</li>
      </ul>
      <h3>Developer</h3>
      <p><strong>Name</strong>: Maksym Didukh</p>
      <p><strong>Email</strong>: didukh.maxim@gmail.com</p>
      <p><strong>GitHub</strong>: <a href="https://github.com/MaksDidukh">github.com/MaksDidukh</a></p>
    </div>
  </div>
  <!-- Модальное окно для Privacy Policy -->
  <div id="privacyModal" class="modal">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal('privacyModal')">Close</button>
      <h2>Privacy Policy</h2>
      <p><strong>Effective Date</strong>: April 18, 2025</p>
      <p>We, Maksym Didukh, the developer of ReadFlowBlocks, are committed to protecting your privacy and ensuring the security of your data. This Privacy Policy explains how we collect, use, store, and protect information related to your use of our application.</p>
      <h3>1. Information Collection</h3>
      <p>ReadFlowBlocks operates locally in your browser. We <strong>do not collect or store personal data</strong> on our servers, except as described below.</p>
      <h4>1.1. User-Uploaded Data</h4>
      <p>- You may upload files in .txt, .pdf, .docx, .html, .epub, or .rtf formats for processing. These files are processed solely in your browser and <strong>are not transmitted to our servers</strong>.</p>
      <p>- The content of uploaded files is temporarily stored in your device's memory for display and is cleared when you close the application or clear your browser cache.</p>
      <h4>1.2. Automatically Collected Data</h4>
      <p>- We <strong>do not collect</strong> data about your interactions with the application (e.g., usage statistics, IP addresses, or browser data).</p>
      <p>- The application uses your browser's local storage (localStorage) to save your reading progress. This data is stored only on your device and can be deleted via your browser settings.</p>
      <h4>1.3. Third-Party Libraries</h4>
      <p>ReadFlowBlocks uses third-party libraries (e.g., pdf.js, mammoth.js, epub.js, rtf.js) to process files. These libraries are loaded via CDNs, which may collect technical data (e.g., IP addresses) per their own privacy policies. We do not control these processes but recommend reviewing the privacy policies of:</p>
      <ul>
        <li><a href="https://mozilla.github.io/pdf.js/">pdf.js</a></li>
        <li><a href="https://github.com/mwilliamson/mammoth.js">mammoth.js</a></li>
        <li><a href="https://github.com/futurepress/epub.js">epub.js</a></li>
        <li><a href="https://github.com/ianjones/rtf.js">rtf.js</a></li>
        <li><a href="https://www.jsdelivr.com/terms/privacy-policy-jsdelivr-net">jsDelivr CDN</a></li>
      </ul>
      <h3>2. Data Usage</h3>
      <p>- Uploaded files are used solely for processing and displaying text in the application.</p>
      <p>- Local storage data is used to save your reading progress for continuity.</p>
      <p>- We <strong>do not share, sell, or use your data</strong> for any other purposes, including marketing or analytics.</p>
      <h3>3. Data Storage and Deletion</h3>
      <p>- Data related to uploaded files is stored only in your device's memory and is cleared upon closing the application or refreshing the page.</p>
      <p>- Local storage data persists until you manually delete it via your browser settings (e.g., clearing cache or site data).</p>
      <p>- We <strong>do not store your data</strong> on our servers or in cloud storage.</p>
      <h3>4. Security</h3>
      <p>We strive to ensure the security of your interaction with the application. However, as ReadFlowBlocks runs in your browser, data security also depends on your device and browser. We recommend:</p>
      <ul>
        <li>Using an up-to-date browser.</li>
        <li>Avoiding uploads of files containing sensitive information if you are unsure about your device's security.</li>
        <li>Running the application via a local server (e.g., <code>python -m http.server</code>) to avoid CORS restrictions.</li>
      </ul>
      <h3>5. User Rights</h3>
      <p>Under data protection laws (e.g., GDPR), you have the right to:</p>
      <ul>
        <li>Know what data is collected (as outlined in Section 1).</li>
        <li>Delete data stored in localStorage via your browser settings.</li>
        <li>Contact us with any privacy-related questions using the contact information below.</li>
      </ul>
      <h3>6. Children</h3>
      <p>ReadFlowBlocks is not intended for use by children under 13 years old. We do not collect data from users under this age. If you believe a child under 13 has used the application, please contact us.</p>
      <h3>7. Changes to This Privacy Policy</h3>
      <p>We may update this Privacy Policy to reflect changes in the application or legal requirements. The updated version will be available within the application.</p>
      <h3>8. Contact Information</h3>
      <p>For any questions, concerns, or requests related to this Privacy Policy, please contact us:</p>
      <p><strong>Email</strong>: didukh.maxim@gmail.com</p>
      <p><strong>GitHub</strong>: <a href="https://github.com/MaksDidukh">github.com/MaksDidukh</a></p>
    </div>
  </div>
  <script type="module">
    // Check if running via file://
    if (window.location.protocol === "file:") {
      alert(
        "Please run the application through a local server (e.g., using VS Code Live Server or the command 'python -m http.server 8000'), otherwise file loading may not work due to CORS restrictions."
      );
    }

    // Load pdf.js
    let pdfjsLib;
    try {
      pdfjsLib = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs");
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.mjs";
      console.log("pdf.js successfully loaded");
    } catch (error) {
      console.error("Error loading pdf.js:", error);
      alert("Failed to load the pdf.js library. Check your internet connection or try again later.");
      throw error;
    }

    // Check library loading
    if (typeof mammoth === "undefined") {
      console.error("mammoth.js library not loaded");
      alert("Failed to load the mammoth.js library for processing .docx files. Check your internet connection.");
    } else {
      console.log("mammoth.js successfully loaded");
    }

    if (typeof ePub === "undefined") {
      console.error("epub.js library not loaded");
      alert("Failed to load the epub.js library for processing .epub files. Check your internet connection.");
    } else {
      console.log("epub.js successfully loaded");
    }

    if (typeof RTFJS === "undefined") {
      console.error("rtf.js library not loaded");
      alert("Failed to load the rtf.js library for processing .rtf files. Check your internet connection.");
    } else {
      console.log("rtf.js successfully loaded");
    }

    // Initialize variables
    let words = [],
      current = 0,
      interval,
      isPaused = false;
    let wordBuffer = [];
    const wordBox = document.getElementById("wordBox");
    const fullTextDiv = document.getElementById("fullText");
    const pageIndicator = document.getElementById("pageIndicator");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const pauseButton = document.getElementById("pauseButton");
    const restartButton = document.getElementById("restartButton");
    const rewindBack = document.getElementById("rewindBack");
    const rewindForward = document.getElementById("rewindForward");
    const navigationSlider = document.getElementById("navigationSlider");
    const chapterSelect = document.getElementById("chapterSelect");
    let wordCount = 3;
    let pdfDocument = null;
    let currentPageBatch = 0;
    let totalPages = 0;
    const pagesPerBatch = 5;
    const renderWindow = 100;
    const bufferThreshold = 500;
    let chapters = [];

    // Welcome message
    const welcomeMessage = "This project was created for you, with the hope that it will spark and simplify your interest in reading books. Dive into the world of stories and knowledge with ease, and let this tool make your reading journey both exciting and effortless!";
    const welcomeWords = welcomeMessage.trim().replace(/\s+/g, " ").split(" ");

    // Set welcome message as default
    words = [...welcomeWords];

    // Update file input text
    function updateFileInputText() {
      const fileInput = document.getElementById("fileInput");
      const fileName = fileInput.files.length > 0 ? fileInput.files[0].name : "No file chosen";
      fileInput.setAttribute("data-file-text", fileName);
    }

    // Update text display
    function updateDisplay() {
      const blockStart = current * wordCount;
      const blockEnd = blockStart + wordCount;

      // Refill word buffer
      if (words.length < bufferThreshold && wordBuffer.length > 0) {
        const batchSize = Math.min(500, wordBuffer.length);
        words = words.concat(wordBuffer.splice(0, batchSize));
        console.log(`Added ${batchSize} words from buffer. Current words size: ${words.length}`);
      }

      // Load next batch for PDF
      if (pdfDocument && blockStart >= words.length - wordCount * 5) {
        setTimeout(loadNextBatch, 0);
      }

      // Check for end of text
      if (blockStart >= words.length) {
        wordBox.innerHTML = "";
        fullTextDiv.innerHTML = words.join(" ");
        pageIndicator.textContent = "End";
        progressText.textContent = "Progress: 100%";
        progressBar.style.width = "100%";
        navigationSlider.value = 100;
        localStorage.setItem("readProgress", current);
        pauseButton.textContent = "Finished";
        pauseButton.disabled = true;
        return;
      }

      // Render text
      const renderStart = Math.max(0, blockStart - renderWindow);
      const renderEnd = Math.min(words.length, blockEnd + renderWindow);
      const highlighted = words
        .slice(renderStart, renderEnd)
        .map((w, i) => {
          const globalIndex = renderStart + i;
          return globalIndex >= blockStart && globalIndex < blockEnd
            ? `<span class="highlight" data-index="${globalIndex}">${w}</span>`
            : `<span data-index="${globalIndex}">${w}</span>`;
        })
        .join(" ");

      const currentWords = words.slice(blockStart, blockEnd).join(" ");

      fullTextDiv.innerHTML = highlighted;
      wordBox.innerHTML = currentWords || "Nothing more to read!";
      wordBox.classList.add("next");
      setTimeout(() => wordBox.classList.remove("next"), 400);
      pageIndicator.textContent = `Page ${Math.floor(blockStart / 200) + 1}`;
      const progressPercent = Math.round((blockStart / words.length) * 100);
      progressText.textContent = `Progress: ${progressPercent}%`;
      progressBar.style.width = `${progressPercent}%`;
      navigationSlider.value = progressPercent;

      // Scroll to highlighted text
      const highlightedSpan = fullTextDiv.querySelector(".highlight");
      if (highlightedSpan) {
        const containerHeight = fullTextDiv.clientHeight;
        const spanHeight = highlightedSpan.offsetHeight;
        const spanTop = highlightedSpan.offsetTop;
        const scrollPosition = spanTop - containerHeight / 2 + spanHeight / 2;
        fullTextDiv.scrollTo({
          top: scrollPosition,
          behavior: "smooth",
        });
      }
    }

    // Start reading
    function startReading() {
      if (isPaused) return;
      clearInterval(interval);
      const speed = parseFloat(document.getElementById("speedSlider").value);
      const accelEnabled = document.getElementById("autoAccel").checked;
      const accelLimit = parseFloat(document.getElementById("accelSlider").value);
      let currentSpeed = speed;
      let delay = 1000 / currentSpeed;
      interval = setInterval(() => {
        const blockStart = current * wordCount;
        if (blockStart < words.length) {
          current++;
          updateDisplay();
          if (accelEnabled && currentSpeed < accelLimit) {
            currentSpeed += 0.02;
            delay = 1000 / currentSpeed;
            clearInterval(interval);
            startReading();
          }
        } else {
          current = Math.floor(words.length / wordCount);
          updateDisplay();
          clearInterval(interval);
        }
      }, delay);
    }

    // Pause/resume
    function togglePause() {
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? "Continue" : "Pause";
      if (!isPaused) startReading();
      else clearInterval(interval);
    }

    // Restart reading
    function restartReading() {
      current = 0;
      isPaused = false;
      pauseButton.textContent = "Pause";
      pauseButton.disabled = false;
      updateDisplay();
      startReading();
    }

    // Start reading from a specific word
    function startReadingFromWord(index) {
      if (index >= 0 && index < words.length) {
        current = Math.floor(index / wordCount);
        clearInterval(interval);
        updateDisplay();
        const clickedWord = fullTextDiv.querySelector(`span[data-index="${index}"]`);
        if (clickedWord) {
          clickedWord.classList.add("clicked");
          setTimeout(() => clickedWord.classList.remove("clicked"), 200);
        }
        if (!isPaused) startReading();
      }
    }

    // Navigate to a percentage of progress
    function navigateToPercent(percent) {
      const totalBlocks = Math.floor(words.length / wordCount);
      current = Math.floor(totalBlocks * (percent / 100));
      current = Math.min(current, totalBlocks);
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    // Rewind backward/forward
    function rewind(direction) {
      const totalBlocks = Math.floor(words.length / wordCount);
      const step = Math.floor(totalBlocks * 0.1);
      if (direction === "back") {
        current = Math.max(0, current - step);
      } else {
        current = Math.min(totalBlocks, current + step);
      }
      clearInterval(interval);
      updateDisplay();
      if (!isPaused) startReading();
    }

    // Load next batch of PDF pages
    async function loadNextBatch() {
      if (!pdfDocument || currentPageBatch * pagesPerBatch >= totalPages) return;

      loadingIndicator.style.display = "block";
      const startTime = performance.now();
      let batchText = "";
      const startPage = currentPageBatch * pagesPerBatch + 1;
      const endPage = Math.min(startPage + pagesPerBatch - 1, totalPages);

      try {
        console.log(`Loading pages ${startPage}-${endPage} of ${totalPages}`);
        for (let i = startPage; i <= endPage; i++) {
          console.log(`Processing page ${i}`);
          const page = await pdfDocument.getPage(i);
          const content = await page.getTextContent();
          const pageText = content.items.map((item) => item.str).join(" ");
          console.log(`Page ${i} text: ${pageText.slice(0, 50)}...`);
          batchText += pageText + " ";
        }

        const newWords = batchText.trim().replace(/\s+/g, " ").split(" ");
        console.log(`Extracted ${newWords.length} words`);
        if (newWords.length > 0) {
          wordBuffer = wordBuffer.concat(newWords);
          updateDisplay();
        }

        currentPageBatch++;
        const endTime = performance.now();
        if (currentPageBatch * pagesPerBatch < totalPages) {
          loadingIndicator.textContent = `Loading... (pages ${startPage}-${endPage} of ${totalPages}, time: ${(endTime - startTime).toFixed(2)} ms)`;
        } else {
          loadingIndicator.style.display = "none";
        }
      } catch (error) {
        console.error("Error loading next batch of pages:", error);
        loadingIndicator.textContent = `Error loading pages: ${error.message}`;
      }
    }

    // Handle uploaded file
    async function handleFile(file) {
      if (!file) {
        alert("Please select a file!");
        return;
      }

      const maxSizeMB = 50;
      if (file.size > maxSizeMB * 1024 * 1024) {
        alert(
          `File is too large (${(file.size / (1024 * 1024)).toFixed(2)} MB). Maximum size: ${maxSizeMB} MB.`
        );
        return;
      }

      const ext = file.name.split(".").pop().toLowerCase();
      let text = "";
      pauseButton.disabled = false;
      pauseButton.textContent = "Pause";
      restartButton.disabled = false;
      pdfDocument = null;
      currentPageBatch = 0;
      totalPages = 0;
      words = [];
      wordBuffer = [];
      chapters = [];
      chapterSelect.style.display = "none";
      chapterSelect.innerHTML = "";
      loadingIndicator.style.display = "none";
      navigationSlider.value = 0;

      try {
        if (ext === "txt") {
          console.log("Processing .txt...");
          text = await file.text();
          if (!text) throw new Error("The .txt file is empty or unreadable.");
          console.log(`Extracted text (.txt): ${text.slice(0, 50)}...`);
        } else if (ext === "html") {
          console.log("Processing .html...");
          const html = await file.text();
          const div = document.createElement("div");
          div.innerHTML = html;
          text = div.innerText;
          if (!text.trim()) throw new Error("The .html file contains no text.");
          console.log(`Extracted text (.html): ${text.slice(0, 50)}...`);
        } else if (ext === "pdf") {
          console.log("Processing .pdf...");
          if (!pdfjsLib) throw new Error("The pdf.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          console.log("Loading PDF document...");
          pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          totalPages = pdfDocument.numPages;
          console.log(`Total pages: ${totalPages}`);
          if (totalPages === 0) throw new Error("The PDF file is empty.");

          let pdfText = "";
          const endPage = Math.min(pagesPerBatch, totalPages);
          loadingIndicator.style.display = "block";
          const startTime = performance.now();
          loadingIndicator.textContent = `Loading... (pages 1-${endPage} of ${totalPages})`;

          for (let i = 1; i <= endPage; i++) {
            console.log(`Processing page ${i}`);
            const page = await pdfDocument.getPage(i);
            const content = await page.getTextContent();
            const pageText = content.items.map((item) => item.str).join(" ");
            console.log(`Page ${i} text: ${pageText.slice(0, 50)}...`);
            pdfText += pageText + " ";
          }
          const endTime = performance.now();
          loadingIndicator.textContent = `Loading... (pages 1-${endPage} of ${totalPages}, time: ${(endTime - startTime).toFixed(2)} ms)`;
          text = pdfText;
          currentPageBatch = 1;
          if (currentPageBatch * pagesPerBatch >= totalPages) {
            loadingIndicator.style.display = "none";
          }
        } else if (ext === "docx") {
          console.log("Processing .docx...");
          if (typeof mammoth === "undefined") throw new Error("The mammoth.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const result = await mammoth.extractRawText({ arrayBuffer });
          text = result.value;
          if (!text.trim()) throw new Error("The .docx file is empty or text could not be extracted.");
          console.log(`Extracted text (.docx): ${text.slice(0, 50)}...`);
        } else if (ext === "epub") {
          console.log("Processing .epub...");
          if (typeof ePub === "undefined") throw new Error("The epub.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const book = ePub(arrayBuffer);
          const contents = await book.opened;

          const toc = await book.loaded.navigation;
          let wordIndex = 0;
          chapters = [];
          for (let item of toc.toc) {
            chapters.push({ label: item.label, href: item.href, startIndex: wordIndex });
            const doc = await book.load(item.href);
            const chapterText = (doc.body.innerText || "") + " ";
            const chapterWords = chapterText.trim().replace(/\s+/g, " ").split(" ");
            wordIndex += chapterWords.length;
          }
          if (chapters.length > 0) {
            chapterSelect.style.display = "block";
            chapters.forEach((chapter, idx) => {
              const option = document.createElement("option");
              option.value = idx;
              option.textContent = chapter.label || `Chapter ${idx + 1}`;
              chapterSelect.appendChild(option);
            });
          }

          let epubText = "";
          for (let spineItem of contents.spine.items) {
            const doc = await book.load(spineItem.href);
            epubText += (doc.body.innerText || "") + " ";
          }
          text = epubText;
          if (!text.trim()) throw new Error("The .epub file is empty or text could not be extracted.");
          console.log(`Extracted text (.epub): ${text.slice(0, 50)}...`);
        } else if (ext === "rtf") {
          console.log("Processing .rtf...");
          if (typeof RTFJS === "undefined") throw new Error("The rtf.js library is not loaded.");
          const arrayBuffer = await file.arrayBuffer();
          const rtfContent = new TextDecoder().decode(arrayBuffer);
          const rtf = new RTFJS.Document(rtfContent);
          text = rtf.getText();
          if (!text.trim()) throw new Error("The .rtf file is empty or text could not be extracted.");
          console.log(`Extracted text (.rtf): ${text.slice(0, 50)}...`);
        } else {
          alert(
            "This format is not supported! Supported formats: .txt, .pdf, .docx, .html, .epub, .rtf."
          );
          return;
        }

        words = text.trim().replace(/\s+/g, " ").split(" ");
        console.log(`Total words after processing: ${words.length}`);
        if (words.length === 0) {
          alert("No words found after processing the file. Try another file.");
          words = [...welcomeWords]; // Revert to welcome message
          return;
        }

        navigationSlider.max = 100;
        navigationSlider.value = 0;

        current = parseInt(localStorage.getItem("readProgress")) || 0;
        isPaused = false;
        updateDisplay();
        startReading();
      } catch (error) {
        console.error(`Error processing file (${ext}):`, error);
        alert(
          `Failed to load file (${ext}): ${error.message}. Check the browser console (F12) for details.`
        );
        loadingIndicator.style.display = "none";
        words = [...welcomeWords]; // Revert to welcome message
        updateDisplay();
        startReading();
      }
    }

    // Event listeners
    document.getElementById("fileInput").addEventListener("change", (e) => {
      updateFileInputText();
      const file = e.target.files[0];
      handleFile(file);
    });

    document.getElementById("speedSlider").addEventListener("input", () => {
      if (!isPaused) startReading();
    });

    document.getElementById("sizeSlider").addEventListener("input", (e) => {
      wordBox.style.fontSize = `${e.target.value}rem`;
    });

    document.getElementById("wordCountSlider").addEventListener("input", (e) => {
      wordCount = Math.max(1, parseInt(e.target.value));
      const currentIndex = current * wordCount;
      current = Math.floor(currentIndex / wordCount);
      updateDisplay();
      if (!isPaused) startReading();
    });

    pauseButton.addEventListener("click", togglePause);
    restartButton.addEventListener("click", restartReading);
    rewindBack.addEventListener("click", () => rewind("back"));
    rewindForward.addEventListener("click", () => rewind("forward"));

    navigationSlider.addEventListener("input", (e) => {
      const percent = parseInt(e.target.value);
      navigateToPercent(percent);
    });

    chapterSelect.addEventListener("change", (e) => {
      const chapterIdx = parseInt(e.target.value);
      const chapter = chapters[chapterIdx];
      if (chapter) {
        const totalBlocks = Math.floor(words.length / wordCount);
        const blockIndex = Math.floor(chapter.startIndex / wordCount);
        current = blockIndex;
        clearInterval(interval);
        updateDisplay();
        if (!isPaused) startReading();
      }
    });

    fullTextDiv.addEventListener("click", (e) => {
      if (e.target.tagName === "SPAN") {
        const index = parseInt(e.target.getAttribute("data-index"));
        if (!isNaN(index)) {
          startReadingFromWord(index);
        }
      }
    });

    // Modal functions
    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = "flex";
      }
    }

    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = "none";
        if (modalId === "welcomeModal" && document.getElementById("dontShowAgain").checked) {
          localStorage.setItem("hideWelcomeModal", "true");
        }
      }
    }

    // Show welcome modal on page load
    window.addEventListener("load", () => {
      if (!localStorage.getItem("hideWelcomeModal")) {
        showModal("welcomeModal");
      }
    });

    // Initialize file input text and start reading welcome message
    updateFileInputText();
    updateDisplay();
    startReading();
  </script>
</body>
</html>
